<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                         "http://www.docbook.org/xml/4.5/docbookx.dtd">

<chapter id="chap.pxe">
  <title>PXE Image—Thin Clients</title>
  <para>A PXE image consists of a boot image and a system image like all
    other image types too. But with a PXE image the image files are
    available seperately and needs to be copied at specific locations of
    a network boot server. PXE is a boot protocol implemented in most
    BIOS implementations which makes it so interesting. The protocol
    sends DHCP requests to assign an IP address and after that it uses
    tftp to download kernel and boot instructions. </para>
  <sect1>
    <title>Setting Up the Required Services</title>
    <para>Before you start to build pxe images with KIWI, setup the boot
      server. The boot server requires the services atftp and DHCP to
      run. </para>
    <sect2>
      <title>Atftp Server</title>
      <para>In order to setup the <systemitem class="server"
          >atftp</systemitem> server the following steps are required </para>

      <procedure>
        <step>
          <para>Install the packages <package>atftp</package> and
              <package>kiwi-pxeboot</package>. </para>
        </step>
        <step>
          <para>Edit the file
            <filename>/etc/sysconfig/atftpd</filename>. Set or modify
            the following variables: </para>
          <itemizedlist>
            <listitem>
              <screen>ATFTPD_OPTIONS="––daemon ––no-multicast"</screen>
            </listitem>
            <listitem>
              <screen>ATFTPD_DIRECTORY="/srv/tftpboot"</screen>
            </listitem>
          </itemizedlist>
        </step>
        <step>
          <para>Run <systemitem class="service">atftpd</systemitem> by
            calling the command:</para>
          <screen><command>rcatftpd</command> start</screen>
        </step>
      </procedure>
    </sect2>

    <sect2>
      <title>DHCP Server</title>
      <para> In contrast to the atftp server setup the following DHCP
        server setup can only serve as an example. Depending on your
        network structure, the IP addresses, ranges and domain settings
        needs to be adapted in order to allow the DHCP server to work
        within your network. If you already have a DHCP server running
        in your network, make sure that the filename and next-server
        information is provided by your server. The following steps
        describe how to setup a new DHCP server instance: </para>

      <procedure>
        <step>
          <para>Install the package <package>dhcp-server</package>.
          </para>
        </step>
        <step>
          <para>Create the file <filename>/etc/dhcpd.conf</filename> and include the
            following statements: </para>
          <screen>option domain-name "example.org";
option domain-name-servers 192.168.100.2;
option broadcast-address 192.168.100.255;
option routers 192.168.100.2;
option subnet-mask 255.255.255.0;
default-lease-time 600;
max-lease-time 7200;
ddns-update-style none; ddns-updates off;
log-facility local7;

subnet 192.168.100.0 netmask 255.255.255.0 {
   filename "pxelinux.0";
   next-server 192.168.100.2;
   range dynamic-bootp 192.168.100.5 192.168.100.20;
}</screen>
        </step>
        <step>
          <para>Edit the file <filename>/etc/sysconfig/dhcpd</filename>
            and setup the network interface the server should listen on: </para>
          <screen>DHCPD_INTERFACE="eth0"</screen>
        </step>
        <step>
          <para>Run the <systemitem class="server">dhcp</systemitem> server by calling:</para>
          <screen><command>rcdhcpd</command> start</screen>
        </step>
      </procedure>
    </sect2>
  </sect1>
  <sect1>
    <title>Building the suse-pxe-client Example</title>
    <para>The example provided with KIWI is based on open­SUSE 11.2 and
      creates an image for a Wyse VX0 terminal with a 128MB flash card
      and 512MB of RAM. The image makes use of the <systemitem
        class="filesystem">squashfs</systemitem> compressed
      filesystem and its root tree is deployed as unified (aufs) based
      system. </para>

    <screen><command>cd</command> /usr/share/doc/packages/kiwi/examples
<command>cd</command> suse-11.2
<command>kiwi</command> –-prepare ./suse-pxe-client -–root /tmp/mypxe</screen>
    <screen><command>kiwi</command> -–create /tmp/mypxe –-type pxe -d /tmp/mypxe-result</screen>
  </sect1>

  <sect1>
    <title>Using the Image</title>
    <para>In order to make use of the image all related image parts
      needs to be copied onto the boot server. According to the example
      the following steps needs to be performed: </para>

    <procedure>
      <step>
        <para>Change working directory:</para>
        <screen><command>cd</command> /tmp/mypxe-result</screen>
      </step>
      <step>
        <para>Copy of the boot and kernel image:</para>
        <screen><command>cp</command> initrd-netboot-suse-11.2.i686-2.1.1.splash.gz \
  /srv/tftpboot/boot/initrd
<command>cp</command> initrd-netboot-suse-11.2.i686-2.1.1.kernel \
  /srv/tftpboot/boot/linux</screen>
      </step>
      <step>
        <para>Copy of the system image and md5 sum:</para>
        <screen><command>cp</command> suse-11.2-pxe-client.i686-1.2.8 /srv/tftpboot/image 
<command>cp</command> suse-11.2-pxe-client.i686-1.2.8.md5 /srv/tftpboot/image</screen>
      </step>
      <step>
        <para>Copy of the image boot configuration. Normally the boot
          configuration applies to one client which means it is required
          to obtain the MAC address of this client. If the boot
          configuration should be used globaly, copy the KIWI generated
          file as config.default: </para>
        <screen><command>cp</command> suse-11.2-pxe-client.i686-1.2.8.config \
  /srv/tftpboot/KIWI/config.<replaceable>MAC</replaceable> </screen>
      </step>
      <step>
        <para>Check the PXE configuration file. The PXE configuration
          controls which kernel and initrd are loaded and which kernel
          parameters are set. When installing the <package>kiwi-pxeboot</package> package,
          a default configuration is added. To make sure the
          configuration is valid according to this example, insert the
          following information into the file
            <filename>/srv/tftpboot/pxelinux.cfg/default</filename>: </para>

        <screen>DEFAULT KIWI-Boot

LABEL KIWI-Boot
    kernel boot/linux
    append initrd=boot/initrd vga=0x314
    IPAPPEND 1

LABEL Local-Boot
    localboot 0</screen>
      </step>
      <step>
        <para>Connect the client to the network and boot. </para>
      </step>
    </procedure>
  </sect1>

  <sect1>
    <title>Flavours</title>
    <para>All the different PXE boot based deployment methods are
      controlled by the
        <filename>config.<replaceable>MAC</replaceable></filename> (or
        <filename>config.default</filename>) file. When a new client
      boots up and there is no client configuration file the new client
      is registered by uploading a control file to the <systemitem
        class="server">TFTP</systemitem> server. The
      following sections informs about the control and the configuration
      file. </para>

    <sect2 id="sec.cntrlhw">
      <title>The PXE Client Control File</title>
      <para>This section describes the netboot client control file: </para>
      <screen>hwtype.$&lt;$MAC Address$&gt;$</screen>
      <para>The control file is primarily used to set up new netboot
        clients. In this case, there is no configuration file
        corresponding to the client MAC address available. Using the MAC
        address information, the control file is created, which is
        uploaded to the <systemitem class="server">TFTP</systemitem> servers upload directory
          <filename>/var/lib/tftpboot/upload</filename>. </para>
    </sect2>

    <sect2 id="sec.confmac">
      <title>The PXE Client Configuration File</title>
      <para>This section describes the netboot client configuration
        file: </para>
      <screen>config.$&lt;$MAC Address$&gt;$</screen>

      <para>The configuration file contains data about image,
        configuration, synchronization, or partition parameters. The
        configuration file is loaded from the TFTP server directory
          <filename>/var/lib/tftpboot/KIWI</filename> via TFTP for
        previously installed netboot clients. New netboot clients are
        immediately registered and a new configuration file with the
        corresponding MAC address is created. The standard case for the
        deployment of a PXE image is one image file based on a
        read-write filesystem which is stored onto a local storage
        device of the client. Below, find an example to cover this case. </para>

      <screen>DISK=/dev/sda
PART=5;S;x,x;L;/
IMAGE=/dev/sda2;suse-11.2-pxe-client.i686;1.2.8;192.168.100.2;4096</screen>

      <para>The following format is used: </para>

      <screen>IMAGE=device;name;version;srvip;bsize;compressed,...,
CONF=src;dest;srvip;bsize,...,src;dest;srvip;bsize
PART=size;id;Mount,...,size;id;Mount
DISK=device</screen>

      <variablelist>
        <varlistentry>
          <term><varname>IMAGE</varname></term>
          <listitem>
            <para>Specifies which image (name) should be loaded with
              which version (version) and to which storage device
              (device) it should be linked, e. g., <filename
                class="devicefile">/dev/ram1</filename> or <filename
                class="devicefile">/dev/hda2</filename>. The netboot
              client partition (device) hda2 defines the root file
              system / and hda1 is used for the swap partition. The
              numbering of the hard disk device should not be confused
              with the RAM disk device, where <filename
                class="devicefile">/dev/ram0</filename> is used for the
              initial RAM disk and can not be used as storage device for
              the second stage system image. SUSE recommends to use the
              device <filename class="devicefile">/dev/ram1</filename>
              for the RAM disk. If the hard drive is used, a
              corresponding partitioning must be performed. </para>

            <variablelist>
              <varlistentry>
                <term>srvip</term>
                <listitem>
                  <para>Specifies the server IP address for the TFTP
                    download. Must always be indicated, except in PART.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>bsize</term>
                <listitem>
                  <para>Specifies the block size for the TFTP download.
                    Must always be indicated, except in PART. If the
                    block size is too small according to the maximum
                    number of data packages (32768), linuxrc will
                    automatically calculate a new blocksize for the
                    download. </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>compressed</term>
                <listitem>
                  <para>Specifies if the image file on the TFTP server
                    is compressed and handles it accordingly. To specify
                    a compressed image download only the keyword
                      <literal>"compressed"</literal> needs to be added.
                    If compressed is not specified the standard download
                    workflow is used. <emphasis role="bold"
                      >Note:</emphasis> The download will fail if you
                    specify <literal>"compressed"</literal> and the
                    image isn’t compressed. It will also fail if you
                    don’t specify <literal>"compressed"</literal> but
                    the image is compressed. The name of the compressed
                    image has to contain the suffix <filename
                      class="extension">.gz</filename> and needs to be
                    compressed with the <command>gzip</command> tool.
                    Using a compressed image will automatically
                      <emphasis>deactivate</emphasis> the multicast
                    download option of atftp. </para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>CONF</varname></term>
          <listitem>
            <para>Specifies a comma-separated list of source:target
              configuration files. The source (src) corresponds to the
              path on the TFTP server and is loaded via TFTP. The
              download is made to the file on the netboot client
              indicated by the target (dest). </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>PART</varname></term>
          <listitem>
            <para>Specifies the partitioning data. The comma-separated
              list must contain the size (size), the type number (id),
              and the mount point (Mount). The size is measured in MB by
              default. Additionally all size specifications supported by
              the sfdisk program are allowed as well. The type number
              specifies the ID of the partition. Valid ID’s are listed
              via the <command>sfdisk</command>
              <option>--list-types</option> command. The mount specifies
              the directory the partition is mounted to. </para>

            <itemizedlist>
              <listitem>
                <para>The first element of the list must define the swap
                  partition. </para>
              </listitem>
              <listitem>
                <para>The second element of the list must define the
                  root partition. </para>
              </listitem>
              <listitem>
                <para>The swap partition must not contain a mount point.
                  A lowercase letter <literal>x</literal> must be set
                  instead. </para>
              </listitem>
              <listitem>
                <para>If a partition should take all the space left on a
                  disk one can set a lower <literal>x</literal> letter
                  as size specification. </para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>DISK</varname></term>
          <listitem>
            <para>Specifies the hard disk. Used only with PART and
              defines the device via which the hard disk can be
              addressed, e.g., <filename class="devicefile"
                >/dev/hda</filename>. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>RELOAD_IMAGE</varname></term>
          <listitem>
            <para>If set to a non-empty string, this forces the
              configured image to be loaded from the server even if the
              image on the disk is up-to-date. The primary purpose of
              this setting is to aid debugging. The option is sensible
              only for disk based systems. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>RELOAD_CONFIG</varname></term>
          <listitem>
            <para>If set to a non-empty string, this forces all config
              files to be loaded from the server. The primary purpose of
              this setting is to aid debugging. The option is sensible
              only for disk based systems. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>COMBINED_IMAGE</varname></term>
          <listitem>
            <para>If set to an non-empty string, indicates that the both
              image specified needs to be combined into one bootable
              image, whereas the first image defines the read-write part
              and the second image defines the read-only part. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>KIWI_INITRD</varname></term>
          <listitem>
            <para>Specifies the KIWI initrd to be used for local boot of
              the system. The variables value must be set to the name of
              the initrd file which is used via PXE network boot. If the
              standard tftp setup suggested with the kiwi-pxeboot
              package is used all initrd files resides in the <filename
                class="directory">boot/</filename> directory below the
              tftp server path <filename class="directory">/var/lib/tftpboot</filename>.
              Because the tftp server do a chroot into the tftp server
              path you need to specify the initrd file as the following
              example shows: </para>
            <screen>KIWI_INITRD=/boot/<replaceable>name-of-initrd-file</replaceable></screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>UNIONFS_CONFIG</varname></term>
          <listitem>
            <para>For netboot and usbboot images there is the
              possibility to use unionfs or aufs as container filesystem
              in combination with a compressed system image. The
              recommended compressed filesystem type for the system
              image is <emphasis role="bold">squashfs</emphasis>. In
              case of a USB stick system the usbboot image will
              automatically setup the unionfs/aufs filesystem. In case
              of a PXE network image the netboot image requires a
                  <filename>config.<replaceable>MAC</replaceable></filename>
              setup like the following example shows: </para>
            <screen>UNIONFS_CONFIG=/dev/sda2,/dev/sda3,aufs</screen>
            <para>In this example the first device <filename
                class="devicefile">/dev/sda2</filename> represents the
              read/write filesystem and the second device <filename
                class="devicefile">/dev/sda3</filename> represents the
              compressed system image filesystem. The container
              filesystem aufs is then used to cover the read/write layer
              with the read-only device to one read/write filesystem. If
              a file on the read-only device is going to be written the
              changes inodes are part of the read/write filesystem.
              Please note the device specifications in
                <varname>UNIONFS_CONFIG</varname> must correspond with
              the IMAGE and PART information. The following example
              should explain the interconnections: </para>

            <screen>IMAGE=/dev/sda3;image/myImage;1.1.1;192.168.1.1;4096
PART=200;S;x,300;L;/,x;L;x
UNIONFS_CONFIG=/dev/sda2,/dev/sda3,aufs
DISK=/dev/sda</screen>

            <para>As the second element of the PART list must define the
              root partition it’s absolutely important that the first
              device in <varname>UNIONFS_CONFIG</varname> references
              this device as read/write device. The second device of
                <varname>UNIONFS_CONFIG</varname> has to reference the
              given IMAGE device name. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>KIWI_KERNEL_OPTIONS</varname></term>
          <listitem>
            <para>Specifies additional command line options to be passed
              to the kernel when booting from disk. For instance, to
              enable a splash screen, you might use
                <literal>vga=0x317</literal>
              <literal>splash=silent</literal>. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>KIWI_BOOT_TIMEOUT</varname></term>
          <listitem>
            <para>Specifies the number of seconds to wait at the grub
              boot screen when doing a local boot. The default is 10.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>NBDROOT</varname></term>
          <listitem>
            <para>Mount the system image root filesystem remotely via
              NBD (Network Block Device). This means there is a server
              which exports the root directory of the system image via a
              specified port. The kernel provides the block layer,
              together with a remote port that uses the nbd-server
              program. For more information on how to set up the server,
              see the nbd-server man pages. The kernel on the remote
              client can set up a special network block device named
                <filename class="devicefile">/dev/nb0</filename> using
              the nbd-client command. After this device exists, the
              mount program is used to mount the root filesystem. To
              allow the KIWI boot image to use that, the following
              information must be provided: </para>

            <screen>NBDROOT=NBD.Server.IP.address;\
  NBD-Port-Number;/dev/NBD-Device;\
  NBD-Swap-Port-Number;/dev/NBD-Swap-Device;\
  NBD-Write-Port-Number;/dev/NBD-Write-Device</screen>

            <para> The NBD-Device, NBD-Swap-Port-Number,
              NBD-Swap-Device, NBD-Write-Port-Number and
              NBD-Write-Device variables are optional. If the nbd root
              device is not set, the default values (<filename
                class="devicefile">/dev/nb0</filename>, port 2000)
              applies and if the nbd swap device is not set the default
              values (<filename class="devicefile">/dev/nb1</filename>,
              port 9210) applies. The swap space over the network using
              a network block device is only established if the client
              has less than 48 MB of RAM. The optional
              NBD-Write-Port-Number and NBD-Write-Device specifies a
              write COW location for the root filesystem. aufs is used
              as overlay filesystem in this case. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>AOEROOT</varname></term>
          <listitem>
            <para>Mount the system image root filesystem remotely via
              AoE (ATA over Ethernet). This means there is a server
              which exports a block device representing the the root
              directory of the system image via the AoE subsystem. The
              block device could be a partition of a real or a virtual
              disk. In order to use the AoE subsystem I recommend to
              install the <package>aoetools</package> and
                <package>vblade</package> packages from here first:
                <ulink
                url="http://download.opensuse.org/repositories/system:/aoetools"
              />. Once installed the following example shows how to
              export the local <filename class="devicefile"
                >/dev/sdb1</filename> partition via AoE:</para>

            <screen><command>vbladed</command> 0 1 eth0 /dev/sdb1 </screen>
            <para> Some explanation about this command, each AoE device
              is identified by a couple Major/Minor, with major between
              0-65535 and minor between 0-255. AoE is based just over
              Ethernet on the OSI models so we need to indicate which
              ethernet card we’ll use. In this example we export
                <filename class="devicefile">/dev/sdb1</filename> with a
              major value of 0 and minor of 1 on the eth0 interface. We
              are ready to use our partition on the network! To be able
              to use the device KIWI needs the information which AoE
              device contains the root filesystem. In our example this
              is the device <filename class="devicefile"
                >/dev/etherd/e0.1</filename>. According to this the
              AOEROOT variable must be set as follows: </para>

            <screen>AOEROOT=/dev/etherd/e0.1</screen>

            <para> KIWI is now able to mount and use the specified AoE
              device as the remote root filesystem. In case of a
              compressed read-only image with <systemitem class="filesystem">aufs</systemitem> 
              or <systemitem class="filesystem">clicfs</systemitem>, the
              AOEROOT variable can also contain a device for the write
              actions: </para>

            <screen>AOEROOT=/dev/etherd/e0.1,/dev/ram1</screen>

            <para> Writing to RAM is the default but you also can set
              another device like another aoe location or a local device
              for writing the data </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>NFSROOT</varname></term>
          <listitem>
            <para>Mount the system image root filesystem remotely via NFS
              (Network File System). This means there is a
              server which exports the root filesystem of the network
              client in such a way that the client can mount it
              read/write. In order to do that, the boot image must know
              the server IP address and the path name where the root
              directory exists on this server. The information must be
              provided as in the following example: </para>

            <screen>NFSROOT=NFS.Server.IP.address;/path/to/root/tree</screen>

            <para> Optionally you can set a <varname>UNIONFS_CONFIG</varname> variable
              which defines an aufs based overlay NFS directory or
              device like: </para>

            <screen>UNIONFS_CONFIG=/tmp/kiwi-11.1-cow,nfs,aufs # write to NFS directory
UNIONFS_CONFIG=/dev/ram1,nfs,aufs # write to RAM</screen>

            <para> This way you can keep the original root tree clean
              from any modifications </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>KIWI_INITRD</varname></term>
          <listitem>
            <para>Specifies the KIWI initrd to be used for a local boot
              of the system. The value must be set to the name of the
              initrd file which is used via PXE network boot. If the
              standard TFTP setup suggested with the kiwi-pxeboot
              package is used, all initrd files reside in the <filename
                class="directory">/srv/tftpboot/boot/</filename>
              directory. Because the TFTP server does a chroot into the
              TFTP server path, you must specify the initrd file as
              follows: </para>

            <screen>KIWI_INITRD=/boot/name-of-initrd-file</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>KIWI_KERNEL</varname></term>
          <listitem>
            <para>Specifies the kernel to be used for a local boot of
              the system The same path rules as described for
                <varname>KIWI_INITRD</varname> applies for the kernel
              setup: </para>

            <screen>KIWI_KERNEL=/boot/name-of-kernel-file</screen>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>ERROR_INTERRUPT</varname></term>
          <listitem>
            <para>Specifies a message which is displayed during first
              deployment. Along with the message a shell is provided.
              This functionality should be used to send the user a
              message if it’s clear the boot process will fail because
              the boot environment or something else influences the pxe
              boot process in a bad way. </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>User another than tftp as Download Protocol</title>
      <para>By default all downloads controlled by the KIWI linuxrc code
        are performed by an atftp call and therefore uses the tftp
        protocol. With PXE the download protocol is fixed and thus you
        can’t change the way how the kernel and the boot image (initrd)
        is downloaded. As soon as Linux takes over control the following
        download protocols http, https and ftp are supported too. KIWI
        makes use of the <command>curl</command> program to support the
        additional protocols. </para>

      <para>In order to select one of the additional download protocols
        the following kernel parameters needs to be setup: </para>

      <variablelist>
        <varlistentry>
          <term><parameter>kiwiserver</parameter></term>
          <listitem>
            <para>Name or IP address of the server who implements the
              protocol </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><parameter>kiwiservertype</parameter></term>
          <listitem>
            <para>Name of the download protocol which could be one of
              http, https or ftp </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>To setup this parameters edit the file
          <filename>/srv/tftpboot/pxelinux.cfg/default</filename> on
        your PXE boot server and change the append line accordingly.
        Please note all downloads except for kernel and initrd are now
        controlled by the given server and protocol. You need to make
        sure that this server provides the same directory and file
        structure as initially provided by the <package>kiwi-pxeboot</package> package.
      </para>
    </sect2>

    <sect2>
      <title>RAM Only Image</title>
      <para>If there is no local storage and no remote root mount setup
        the image can be stored into the main memory of the client.
        Please be aware that there should be still enough RAM space
        available for the operating system after the image has been
        deployed into RAM. Below, find an example: </para>


      <itemizedlist>
        <listitem>
          <para>Use a read-write filesystem in
              <filename>config.xml</filename>, for example
              <literal>filesystem="ext3"</literal>
          </para>
        </listitem>
        <listitem>
          <para>Create
              <filename>config.<replaceable>MAC</replaceable></filename>
          </para>
          <screen>IMAGE=/dev/ram1;suse-11.2-pxe-client.i686;\
      1.2.8;192.168.100.2;4096</screen>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Union Image</title>
      <para>As used in the suse-pxe-client example it is possible to
        make use of the aufs or unionfs overlay filesystems to combine
        two filesystems into one. In case of thin clients there is often
        the need for a compressed filesystem due to space limitations.
        Unfortunately all common compressed filesystems provides only
        read-only access. Combining a read-only filesystem with a
        read-write filesystem is a solution for this problem. In order
        to use a compressed root filesystem make sure your
          <filename>config.xml</filename>’s filesystem attribute
        contains either <systemitem class="filesystem">squashfs</systemitem> 
        or <systemitem class="filesystem">clicfs</systemitem>. Below, find an example: </para>

      <screen>DISK=/dev/sda
PART=5;S;x,62;L;/,x;L;x,
IMAGE=/dev/sda2;suse-11.2-pxe-client.i386;\
      1.2.8;192.168.100.2;4096
UNIONFS_CONFIG=/dev/sda3,/dev/sda2,aufs
KIWI_INITRD=/boot/initrd</screen>
    </sect2>

    <sect2>
      <title>Split Image</title>
      <para>As an alternative to the <varname>UNIONFS_CONFIG</varname>
        method it is also possible to create a split image and combine
        the two portions with the <varname>COMBINED_IMAGE</varname>
        method. This allows to use different filesystems without the
        need for an overlay filesystem to combine them together. Below
        find an example: </para>

      <itemizedlist>
        <listitem>
          <para>Add a split type in <filename>config.xml</filename>, for
            example </para>
          <screen>&lt;type fsreadonly="squashfs" 
   image="split" fsreadwrite="ext3" boot="netboot/suse-11.2"/&gt;</screen>
        </listitem>
        <listitem>
          <para>Add a split section inside the type to describe the
              <sgmltag>temporary</sgmltag> and
              <sgmltag>persistent</sgmltag> parts. For example:</para>

          <screen>&lt;split&gt;
  &lt;temporary&gt; 
    <sgmltag class="sgmlcomment"> allow RAM read/write access to: </sgmltag>
    &lt;file name="/mnt"/&gt; 
    &lt;file name="/mnt/*"/&gt; 
  &lt;/temporary&gt;
  &lt;persistent&gt;
    <sgmltag class="sgmlcomment"> allow DISK read/write access to: </sgmltag>
    &lt;file name="/var"/&gt; 
    &lt;file name="/var/*"/&gt; 
    &lt;file name="/boot"/&gt; 
    &lt;file name="/boot/*"/&gt;
    &lt;file name="/etc"/&gt; 
    &lt;file name="/etc/*"/&gt;
    &lt;file name="/home"/&gt;
    &lt;file name="/home/*"/&gt;
  &lt;/persistent&gt; 
&lt;/split&gt;</screen>
        </listitem>
        <listitem>
          <para>Sample
              <filename>config.<replaceable>MAC</replaceable></filename>: </para>

          <screen>IMAGE=/dev/sda2;suse-11.2-pxe-client.i686;\
      1.2.8;192.168.100.2;4096,\
      /dev/sda3;suse-11.2-pxe-client-read-write.i686;\
      1.2.8;192.168.100.2;4096
PART=200;S;x,500;L;/,x;L;
DISK=/dev/sda
COMBINED_IMAGE=yes
KIWI_INITRD=/boot/initrd</screen>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Root Tree Over NFS</title>
      <para> Instead of installing the image onto a local storage device
        of the client it is also possible to let the client mount the
        root tree via an <systemitem class="service">NFS</systemitem>
        remote mount. Below find an example: </para>

      <itemizedlist>
        <listitem>
          <para>Export the KIWI prepared tree via NFS.</para>
        </listitem>
        <listitem>
          <para>Sample
              <filename>config.<replaceable>MAC</replaceable></filename>: </para>
          <screen>NFSROOT=192.168.100.7;/tmp/kiwi.nfsroot</screen>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Root Tree Over NBD</title>

      <para>As an alternative for root over NFS it is also possible to
        let the client mount the root tree via a special network block
        device. Below find an example: </para>

      <itemizedlist>
        <listitem>
          <para>Use nbd-server to export the KIWI prepared tree.</para>
        </listitem>
        <listitem>
          <para>Sample
              <filename>config.<replaceable>MAC</replaceable></filename>
          </para>
          <screen>NBDROOT=192.168.100.7;2000;/dev/nbd0</screen>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Root Tree Over AoE</title>
      <para>As an alternative for root over NBD it is also possible to
        let the client mount the root device via a special ATA over
        Ethernet network block device. Below find an example: </para>


      <itemizedlist>
        <listitem>
          <para>Use the <command>vbladed</command> command to bind a
            block device to an ethernet interface. The block device can
            be a disk partition or a loop device (losetup) but not a
            directory like with NBD. </para>
        </listitem>
        <listitem>
          <para>Sample
              <filename>config.<replaceable>MAC</replaceable></filename>: </para>
          <screen>AOEROOT=/dev/etherd/e0.1</screen>
          <para>This would require the following command to be called
            first:</para>
          <screen><command>vbladed</command> 0 1 eth0 blockdevice</screen>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>
